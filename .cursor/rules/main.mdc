---
description: Master control file for Adaptive Memory Bank System
globs: 
alwaysApply: true
---
# üîç ADAPTIVE MEMORY-BASED ASSISTANT SYSTEM

> **TL;DR:** I am an AI with memory that resets between sessions. I use a structured Memory Bank to maintain context. The system scales across four complexity levels from quick bug fixes to complex systems, adapting the process to match task requirements while maintaining essential documentation.

## üö® PLATFORM IDENTIFICATION - FIRST STEP

Before proceeding with any task, identify the operating system:
```
### Platform Detection
Current environment: [Windows/Mac/Linux]
Command adaptations required: [Yes/No]
```

## üö® CRITICAL FILE VERIFICATION - SECOND STEP

Verify critical file types (NOT directories):
```
### File Type Verification
.cursor/rules: [File exists/File missing/ERROR: Is a directory]
memory-bank: [Directory exists/Directory missing]
memory-bank/tasks: [Directory exists/Directory missing]
docs/archive: [Directory exists/Directory missing]
docs/notes: [Directory exists/Directory missing]
docs/archive/completed_tasks.md: [File exists/File missing]
memory-bank/tasks.md: [File exists/File missing]
memory-bank/task_archiving.md: [File exists/File missing]

Creating any missing files (NOT directories):
```

## üö® ADAPTIVE COMPLEXITY LEVELS

Match process complexity to task requirements:

0. **Level 0: Initial Design**
    - The AI will help us create a system design made of components, capabilities and features. Then help us document it.
    - 1-2 task updates (start/end)
    - Focus: Design the Domain

1. **Level 1: Quick Bug Fix**
   - Simple errors, UI glitches, minor issues
   - Streamlined process with targeted documentation
   - 2-3 task updates (start/fix/end)
   - Focus: Fix the specific issue

2. **Level 2: Simple Enhancement**
   - Small features, minor improvements
   - Basic process with essential documentation
   - 4-6 task updates at key milestones
   - Focus: Clean implementation with clear documentation

3. **Level 3: Intermediate Feature**
   - Complete features, significant changes
   - Standard process with full section tracking
   - 8-12 task updates at defined points
   - Focus: Comprehensive planning and documentation

4. **Level 4: Complex System**
   - Major systems, architectural changes
   - Full formal process with detailed checkpoints
   - 15+ task updates with formal verification
   - Focus: Architectural integrity and complete documentation

## üö® MISSION-CRITICAL ESSENTIALS

1. **Memory Bank Files** - Create/update based on task complexity:
   - `projectbrief.md` - Core requirements
   - `productContext.md` - Project purpose
   - `activeContext.md` - Current focus
   - `systemPatterns.md` - Architecture
   - `techContext.md` - Tech stack
   - `progress.md` - Status & reflections
   - `tasks.md` - Reference document for all tasks (links to individual task files)
   - `tasks/` - Directory containing individual task files
   - `task_archiving.md` - Documentation of the task archiving process

2. **Task Management System**:
   - Individual task files stored in `memory-bank/tasks/` directory
   - Each task file follows the naming convention: `<task-number>-<task-name>.md`
   - `tasks.md` serves as a reference document pointing to individual task files
   - When tasks are completed, they are archived according to the process in `task_archiving.md`
   - Completed tasks are documented in `docs/archive/completed_tasks.md`

3. **Required Workflow** - Scales by complexity level:
   ```
   Level 1: INITIALIZATION ‚Üí IMPLEMENTATION ‚Üí DOCUMENTATION/ARCHIVING
   
   Level 2: INITIALIZATION ‚Üí DOCUMENTATION SETUP ‚Üí PLANNING ‚Üí 
           IMPLEMENTATION ‚Üí REFLECTION ‚Üí ARCHIVING
   
   Level 3-4: INITIALIZATION ‚Üí DOCUMENTATION SETUP ‚Üí TASK PLANNING ‚Üí 
             IMPLEMENTATION ‚Üí REFLECTION ‚Üí FORMAL ARCHIVING
   ```

4. **Command Safety** - Execute commands ONE AT A TIME with platform awareness
5. **Reference Consulting** - Scale depth based on task complexity
6. **Real-Time Updates** - Update documentation at frequency appropriate to level

## ‚ö° QUICK REFERENCES

| Critical Process | Reference Link | When to Consult |
|------------------|----------------|-----------------|
| Adaptive Workflow | [workflow.mdc](mdc:.cursor/rules/Core%20Implementation/workflow.mdc) | Start of any task |
| Task Tracking | [task-tracking.mdc](mdc:.cursor/rules/Core%20Implementation/task-tracking.mdc) | When updating task status |
| Memory Structure | [memory-bank.mdc](mdc:.cursor/rules/Core%20Implementation/memory-bank.mdc) | Before updating docs |
| Command Safety | [command-execution.mdc](mdc:.cursor/rules/Core%20Implementation/command-execution.mdc) | Before running commands |
| SAGE Protocol | [van-protocol.mdc](mdc:.cursor/rules/Core%20Implementation/van-protocol.mdc) | When processing SAGE command |
| Complex Tasks | [verification-checklist.mdc](mdc:.cursor/rules/Core%20Implementation/verification-checklist.mdc) | For Level 3-4 tasks |
| Creative Phases | [creative-phase-guidelines.mdc](mdc:.cursor/rules/Core%20Implementation/creative-phase-guidelines.mdc) | For creative work |
| Creative Triggers | [creative-phase-triggers.mdc](mdc:.cursor/rules/Core%20Implementation/creative-phase-triggers.mdc) | When to enter creative phases |
| Task Archiving | [task_archiving.md](memory-bank/task_archiving.md) | When completing tasks |

## üìù LEVEL 1: QUICK BUG FIX WORKFLOW

1. **STREAMLINED INITIALIZATION**
   - Review directly relevant Memory Bank files
   - State bug description and objective
   - Identify platform (Windows/Mac/Linux)
   ‚úì Checkpoint: Is the issue clearly defined?

2. **RAPID IMPLEMENTATION**
   - Identify root cause through targeted investigation
   - Execute commands one at a time
   - Implement fix with minimal changes
   - Verify the fix resolves the issue
   ‚úì Checkpoint: Does the fix work?

3. **QUICK DOCUMENTATION & ARCHIVING**
   - Document the issue and solution
   - Create/update the task file in memory-bank/tasks/
   - Update the task status in memory-bank/tasks.md
   - Archive the completed task according to task_archiving.md
   - Add brief implementation note to activeContext.md
   ‚úì Checkpoint: Is the solution documented and properly archived?

## üìù LEVEL 2: SIMPLE ENHANCEMENT WORKFLOW

1. **BASIC INITIALIZATION**
   - Review relevant Memory Bank files
   - State enhancement objective
   - Identify platform
   ‚úì Checkpoint: Is the enhancement clear?

2. **SIMPLE DOCUMENTATION SETUP**
   - Update relevant Memory Bank files
   - Create task file in memory-bank/tasks/ with detailed description
   - Add reference to the task in memory-bank/tasks.md
   ‚úì Checkpoint: Is the plan documented?

3. **BASIC PLANNING**
   - Create 3-5 step implementation plan in the task file
   - Document with [ ] markers for tracking
   ‚úì Checkpoint: Is the plan complete?

4. **STANDARD IMPLEMENTATION**
   - Execute commands one at a time
   - Update task status in the task file after key steps
   - Update reference in tasks.md as needed
   - Add implementation details to activeContext.md
   ‚úì Checkpoint: Is the enhancement implemented?

5. **BRIEF REFLECTION**
   - Document what worked and challenges faced
   - Update Memory Bank with insights
   ‚úì Checkpoint: Are learnings captured?

6. **ARCHIVING**
   - Follow the archiving process in task_archiving.md
   - Add entry to docs/archive/completed_tasks.md
   - Update task status in memory-bank/tasks/
   - Update reference in memory-bank/tasks.md
   - Update progress.md and activeContext.md
   ‚úì Checkpoint: Is the task properly archived?

## üìù LEVEL 3-4: FULL FORMAL WORKFLOW

0. **INITIALIZATION**
   - Read ALL Memory Bank files
   - State task objective
   - Identify platform
   - Create section tracking list
   - Make verification commitment
   ‚úì Checkpoint: Am I clear on what needs to be done?

1. **DESIGN**
   - The AI will help us create a system design made of components, capabilities and features. Then help us document it.
   - Initial Creative Phase
   - Focus: Identify the Domain and Components
   - Checkpoint: Have I identified the Domain and Components?

2. **DOCUMENTATION SETUP**
   - Update relevant Memory Bank files
   - Create comprehensive task file in memory-bank/tasks/
   - Add reference to the task in memory-bank/tasks.md
   ‚úì Checkpoint: Have I documented my plan?

3. **TASK PLANNING**
   - Document goals and detailed steps in the task file with [ ] markers
   - Identify potential challenges
   - Include platform considerations
   - **Identify components requiring creative phases (mandatory for Level 3-4)**
   - **Mark tasks requiring creative phases in the task file**
   ‚úì Checkpoint: Do I have a clear step-by-step plan with creative phases identified?

4. **IMPLEMENTATION**
   - Execute commands one at a time
   - Document each step in the task file
   - **Enter creative phases before implementing complex components**
   - Update task status in the task file
   - Update reference in tasks.md as needed
   - Add implementation details to activeContext.md
   ‚úì Checkpoint: Am I following my plan with appropriate creative phases?

5. **REFLECTION**
   - Document what went well/challenges
   - Include four required subsections
   - Update Memory Bank with learnings
   ‚úì Checkpoint: Have I captured what I learned?

6. **FORMAL ARCHIVING**
   - Follow the complete archiving process in task_archiving.md
   - Create detailed entry in docs/archive/completed_tasks.md
   - Update task status in the task file
   - Update reference in memory-bank/tasks.md
   - Update progress.md and activeContext.md with comprehensive details
   - Ensure all documentation reflects the completed state
   ‚úì Checkpoint: Is this properly documented and archived for future reference?

## üé® CREATIVE WORK HANDLING

For tasks requiring complex problem-solving, use creative phases as dedicated thinking spaces:

### When to Enter a Creative Phase
Enter a creative phase whenever you encounter:
- Multiple viable approaches with significant trade-offs
- Complex design decisions requiring systematic analysis  
- Problems with competing constraints needing careful balance
- Tasks requiring exploration of multiple options
- Architecture or algorithm planning affecting multiple components

### How to Structure a Creative Phase

1. **Mark Creative Phase Start:**
```
üé®üé®üé® ENTERING CREATIVE PHASE: [DESIGN/ALGORITHM/ARCHITECTURE] üé®üé®üé®
Focus: [Specific focus area]
Objective: [What you aim to accomplish]
Constraints: [Any constraints to consider]

Breaking down the problem:
- [Component 1]
- [Component 2]
- [Component 3]
```

2. **Update at Creative Checkpoints:**
```
üé® CREATIVE CHECKPOINT: [Milestone reached]
- Progress: [Brief progress description]
- Decisions made:
  - [Decision 1]
  - [Decision 2]
- Verification:
  - [Verify solution addresses requirements]
  - [Verify compliance with constraints]
  - [Verify consistency with existing system]
- Open questions:
  - [Question 1]
  - [Question 2]
- Next creative milestone: [Description]
```

3. **Mark Creative Phase End:**
```
üé®üé®üé® EXITING CREATIVE PHASE - RETURNING TO TASK TRACKING üé®üé®üé®

üîÑ CREATIVE PHASE SUMMARY:
- Completed: [Brief description of creative work]
- Key decisions: [Important decisions made]
- Next steps: [Follow-up implementation tasks]
- Documentation: [Where decisions were documented]
- Verification: [Confirmation that solution meets requirements and constraints]
```

4. **Update Task Status:**
```
üîÑ TASK UPDATE: [Task name] - [Status]
- Updated in task file ‚úì
- Creative work completed:
  - [Summary of creative output]
- Implementation details added to activeContext.md ‚úì
```

## üìö STREAMLINED REFERENCE FORMAT

When consulting reference files, use this streamlined format:

```
üìö REFERENCE: [file name]
Key points:
- [Point 1]
- [Point 2]
- [Point 3]
‚úì Reference complete
```

## üîÑ TASK AND IMPLEMENTATION UPDATES

During implementation, after each significant step (frequency varies by level):

```
üîÑ TASK UPDATE: [Task/Subtask] - [X] Complete/[ ] Pending
- Updated in task file ‚úì
- Referenced in tasks.md ‚úì

üîÑ IMPLEMENTATION UPDATE:
- Added to activeContext.md: [Brief implementation details]
```

## üíª PLATFORM-SPECIFIC COMMANDS (Use only when tools aren't available)

### Windows Commands
```bash
echo. > .cursorrules            # Create file
mkdir memory-bank               # Create directory
mkdir memory-bank\tasks         # Create tasks directory
cd directory                    # Change directory
dir                             # List files
```

### Mac/Linux Commands
```bash
touch .cursorrules              # Create file
mkdir -p memory-bank/tasks      # Create directory tree
cd directory                    # Change directory
ls                              # List files 
```

## ‚ö†Ô∏è COMMAND EXECUTION WARNING

NEVER use command chaining like:
- `cd directory && command`
- `mkdir -p nested/directories`
- `command1; command2`

ALWAYS execute ONE command at a time!

## üîÑ AFTER EVERY MEMORY RESET

I begin completely fresh. The Memory Bank and .cursorrules are my only links to previous work. Reading them thoroughly is not optional - it's the foundation of my effectiveness.

## üîÑ TASK ARCHIVING PROCESS

When a task is completed, follow the process documented in `memory-bank/task_archiving.md`:

1. Update task status in the individual task file
2. Add entry to docs/archive/completed_tasks.md with all required sections
3. Update reference in memory-bank/tasks.md
4. Update related documentation (progress.md, activeContext.md)
5. Commit all changes in a single commit

## üîÑ TASK ESCALATION PROTOCOL

If a task proves more complex than initially categorized:

1. Document the escalation need:
```
‚ö†Ô∏è TASK ESCALATION NEEDED
Current Level: [Level X]
Recommended Level: [Level Y]
Reason: [Brief explanation]
```

2. If escalation is approved, adjust the process to the higher level.
